:sectnums:
:sectnumlevels: 3
:markup-in-source: verbatim,attributes,quotes
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
:format_cmd_exec: source,options="nowrap",subs="{markup-in-source}",role="copy"
:format_cmd_output: bash,options="nowrap",subs="{markup-in-source}"
ifeval::["%cloud_provider%" == "ec2"]
:format_cmd_exec: source,options="nowrap",subs="{markup-in-source}",role="execute"
endif::[]



:toc:
:toclevels: 1

= Introducing NFTables

== Overview

NFTables is the subsystem of the Linux kernel which provides filtering and classification of network packets, datagrams, or frames. This software provides an in-kernel packet classification framework that is based on a network-specific Virtual Machine (VM) and a new nft userspace command line tool.

Primary benefits:

  * Better performance
  * Better usability

=== History

It is not unusual for this subsystem of the linux kernel to get replaced from time to time.  You may be familiar with some of the prior filter systems:

  * ip-firewall (linux kernel v2.0, managed with ipfwadm)
  * ip-chains (linux kernel v2.2, managed with ipchains)
  * ip-tables (linux kernel v2.4, managed with iptables)
  * nf-tables (linux kernel v3.13, managed with nft)

There are others, but these are the most famliar ones that appeared in the major distributions.

=== Recommended Usage

In which scenario should you use one of the following?

  * *firewalld*: for simple firewall use cases. It is easy to use and covers the typical use cases.
  * *nftables*: for complex and performance critical firewalls.
  * *iptables*: Red Hat Enterprise Linux uses the nf_tables kernel API instead of the legacy back end, thus the nf_tables API provides backward compatibility so that scripts that use iptables commands still work. For new firewall scripts, Red Hat recommends to use nftables.

The default firewall management tool in RHEL 9 continues to be firewalld _(firewall-cmd)_, which gained support for nftables with version 0.6.0.

NOTE: For 99% of all use cases the firewalld tools are the best choice.  For this lab however we are trying to introduce `nft` and demonstrate some differences to the former `iptables`.


== Getting Started

For these exercises, you will be using the host `node2` as user `root`.

From host `bastion`, ssh to `node2`.

[{format_cmd_exec}]
----
*ssh node2*
----

Use `sudo` to elevate your privileges.

[{format_cmd_exec}]
----
*sudo -i*
----

Verify that you are on the right host for these exercises.

[{format_cmd_exec}]
----
*workshop-nftables-checkhost.sh*
----

You are now ready to proceed with these exercises.

== Disable Firewalld


[{format_cmd_exec}]
----
*systemctl disable firewalld --now*
----

[{format_cmd_exec}]
----
*systemctl enable nftables --now*
----



== Tables

Fundamentally speaking, filter rules are organized into chains and the chains are then further organized into tables.

Tables are the top-level construct within the nftables ruleset.

A table consists of:

  * *chains*
  * *sets*
  * *maps*
  * *flowtables*
  * *stateful objects*

Each table belongs to exactly one family:

  * *ip* - IPv4
  * *ip6* - IPv6
  * *inet* - both IPv4 and IPv6
  * *arp* 
  * *bridge*
  * *netdev*

So your ruleset requires at least one table for each family you want to filter.

Using nft, show the current state of the network tables.

[{format_cmd_exec}]
----
*nft list tables*
----

There is nothing there, so let us create a new table called 'workshop'

[{format_cmd_exec}]
----
*nft add table inet workshop*
----

[{format_cmd_exec}]
----
*nft list tables*
----


[{format_cmd_output}]
----
table inet workshop
----

== Chains

NOTE: Unlike in iptables, there are no predefined chains like INPUT, OUTPUT, etc. 

A *chain* is a collection of attached *rules* that take action on network packets (ie: accept, drop).

Chain types are:

  * *filter* -  filters packets (supported by the arp, bridge, ip, ip6 and inet families)
  * *route* - reroutes packets (supported by the ip, ip6 and inet families)
  * *nat* -  performs Networking Address Translation (supported by the ip, ip6 and inet families)

Hooks you can use:

  * *ingress* - sees packets immediately after passed up from NIC driver, before prerouting (only in netdev family since Linux kernel 4.2, and inet family since Linux kernel 5.10)
  * *prerouting* : sees all incoming packets, before any routing decision has been made
  * *input* : sees incoming packets that are addressed to and have now been routed to the local system
  * *forward* : sees incoming packets that are not addressed to the local system
  * *output* : sees packets that originated from processes in the local machine
  * *postrouting* : sees all packets after routing, just before they leave the local system

Using nft, show the current state of the network chains.

[{format_cmd_exec}]
----
*nft list chains*
----

Again there is nothing there, so let use create a new chain in our table called 'INPUT'.

NOTE: nft re-uses special characters (ie: curly braces and semicolons) so using single quotes is needed in this case

[{format_cmd_exec}]
----
*nft 'add chain inet workshop INPUT { type filter hook input priority 0 ; }'*
----

[{format_cmd_exec}]
----
*nft list chains*
----

[{format_cmd_output}]
----
table inet workshop {
        chain INPUT {
                type filter hook input priority filter; policy accept;
        }
}
----


== Rules

=== Add Single Rule

[{format_cmd_exec}]
----
*nft insert rule inet workshop INPUT tcp dport http counter*
----

Verify the rule change.

[{format_cmd_exec}]
----
*nft -n -a list table inet workshop*
----

[{format_cmd_output}]
----
table inet workshop { # handle 2
        chain INPUT { # handle 1
                type filter hook input priority 0; policy accept;
                tcp dport 80 counter packets 0 bytes 0 # handle 4
        }
}
----

Now is a good time to point out that the exercises in this unit are deliberately meant to be nondestructive.  Meaning, we don't want this machine to be unusable due to an error in rule insertion or deletion.

So what does the previos rule do?  It merely counts packaets that arrived at port 80 on our machine.  Let's send some packets.

[{format_cmd_exec}]
----
*curl localhost*
----

There is no web server running on this system so you will get a failed connection message.  However, now we reexamine the counters.

[{format_cmd_exec}]
----
*nft -n -a list table inet workshop*
----

[{format_cmd_output}]
----
table inet workshop { # handle 2
        chain INPUT { # handle 1
                type filter hook input priority 0; policy accept;
                tcp dport 80 counter packets 2 bytes 140 # handle 4
        }
}
----

Not too exciting, but now you know how to add a rule.

=== Delete Single Rule

Deleting rules takes a little care in that you have to identify a *handle*.  Again, listing the rules make note of the *handle* provided next to each rule.

[{format_cmd_exec}]
----
*nft -n -a list table inet workshop*
----


[{format_cmd_output}]
----
table inet workshop { # handle 2
        chain INPUT { # handle 1
                type filter hook input priority 0; policy accept;
                tcp dport 80 counter packets 2 bytes 140 # *handle 4*
        }
}
----

We can now use that *handle* to delete the rule.

[{format_cmd_exec}]
----
*nft delete rule workshop INPUT handle 4*
----

Verify the rule change.

[{format_cmd_exec}]
----
*nft -n -a list table ip filter*
----

[{format_cmd_output}]
----
table inet workshop { # handle 2
        chain INPUT { # handle 1
                type filter hook input priority 0; policy accept;
        }
}
----


=== Add Multiple Rules at Once

[{format_cmd_exec}]
----
*nft insert rule inet workshop INPUT tcp dport { ssh, http, https, 8181 } counter*
----

Verify the new rules.

[{format_cmd_exec}]
----
*nft -n -a list table ip filter*
----

[{format_cmd_output}]
----
table inet workshop { # handle 2
        chain INPUT { # handle 1
                type filter hook input priority 0; policy accept;
                tcp dport { 22, 80, 443, 8181 } counter packets 10 bytes 712 # handle 6
        }
}
----

== Increase Network Security

WARNING: DO NOT do this step unless you successfully completed "Add Multiple Rules at Once" above.  You will get locked out of your network connection to node2.example.com if you have not.

Set the INPUT chain default policy to drop all traffic not specifically accepted.

[{format_cmd_exec}]
----
*nft add chain ip filter INPUT { type filter hook input priority 0\; policy drop\; }*
----

Verify Increased Security

[{format_cmd_exec}]
----
*nft -n -a list table ip filter*
----

[{format_cmd_output}]
----
table ip filter { # handle 1
        chain INPUT { # handle 1
                type filter hook input priority 0; policy drop;
                tcp dport { ssh, http, https, 8181 } accept # handle 6
        }

        chain FORWARD { # handle 2
                type filter hook forward priority 0; policy accept;
        }

        chain OUTPUT { # handle 3
                type filter hook output priority 0; policy accept;
        }
}
----

== Cleanup

Remove rules added during this exercise.  We begin by setting the INPUT chain default policy to accept all traffic.

[{format_cmd_exec}]
----
*nft add chain ip filter INPUT { type filter hook input priority 0\; policy accept\; }*
----

Now find the handle and remove the rule currently allowing access for SSH, HTTP, HTTPS, and 8181

[{format_cmd_exec}]
----
*nft -n -a list table ip filter*
----

[{format_cmd_output}]
----
table ip filter { # handle 1
        chain INPUT { # handle 1
                type filter hook input priority 0; policy accept;
                tcp dport { ssh, http, https, 8181 } accept # handle 6
        }

        chain FORWARD { # handle 2
                type filter hook forward priority 0; policy accept;
        }

        chain OUTPUT { # handle 3
                type filter hook output priority 0; policy accept;
        }
}
----

In the output above, we determine the handle for our rule is '6'.

[{format_cmd_exec}]
----
*nft delete rule filter INPUT handle 6*
----

NOTE: You can also use the 'flush' option to clear an entire table: `nft flush table ip filter`

Verify that everything is back to normal

[{format_cmd_exec}]
----
*nft -n -a list table ip filter*
----

[{format_cmd_output}]
----
table ip filter { # handle 1
        chain INPUT { # handle 1
                type filter hook input priority 0; policy accept;
        }

        chain FORWARD { # handle 2
                type filter hook forward priority 0; policy accept;
        }

        chain OUTPUT { # handle 3
                type filter hook output priority 0; policy accept;
        }
}
----

== Additional Resources

You can find more information:

  * link:https://netfilter.org/projects/nftables[Project Page]
  * link:https://en.wikipedia.org/wiki/Nftables[Wikipedia NFTables]
  * link:https://wiki.nftables.org/wiki-nftables/index.php/Main_Page[NFTables How-To]
  * link:https://wiki.nftables.org/wiki-nftables/index.php/Quick_reference-nftables_in_10_minutes[Quick Reference]
  * link:https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/configuring_firewalls_and_packet_filters/getting-started-with-nftables_firewall-packet-filters[Getting started with nftables]

[discrete]
== End of Unit

ifdef::env-github[]
link:../RHEL9-Workshop.adoc#toc[Return to TOC]
endif::[]

////
Always end files with a blank line to avoid include problems.
////
